/**
 * Проверяет сгенерированную головоломку на решение.
 * Контролирует генерацию самого сложного варианта для 
 * данной комбинации
 */
public class SudokuSolution
{
    private int[][] myBoard;
 
    public SudokuSolution(int board[][]) {
        myBoard = board;
    }
    /**
     * Метод, который возвращает количество возможных значений 
     * в заданной позиции. Необходим для генерации новой головоломки
     */
    public int howManyValuesCanBeHere(int r, int c){
    	/* Переменная значения, отвечающая, может ли он быть в данной позиции */
    	boolean canBeHere;
    	/* Массив возможных значений */
    	int[] possibleValues = new int[9];
    	int positionCounter = 0; //Счётчик массива возможных значений
    	/* Перебор значений в данной позиции */
    	for(int value = 1; value < 10; value++){
    		/* По умолчанию допускается, что значение может находится в данной позиции */
    		canBeHere = true;	
    		/* Может ли выбранное значение присутствовать в данной строке? */
	    	for(int j = 0; j < 9; j++){
	    		/* 
	    		 * При условии, что пустые клетки отмечаются отрицательным значением
	    		 * Если найдено соответствие в строке, то значение не может быть здесь
	    		 */
	    		if(myBoard[r][j] == value){
	    			canBeHere = false;
	    		}
	    	}
	    	/* Проверяется возможность присутствия в строке */
	    	if(canBeHere){
	    		/* 
	    		 * Если значение может находиться в данной строке,
	    		 * то добавить в массив возможных значений
				 */
	    		possibleValues[positionCounter] = value;
	    		positionCounter++;	//Подготовка позиции следующего элемента
	    	}
    	}
	    /* 
	     * Последовательно проверить, может ли присутствовать в столбце
	     * элемент массива возможных значений
	     */
    	for(int n = 0; n < positionCounter; n++){
    		canBeHere = true;	//Установить параметр
    		/* Может ли возможное значение присутсвовать в данной строке? */
    		for(int i = 0; i < 9; i++){
    			/* 
	    		 * При условии, что пустые клетки отмечаются отрицательным значением
	    		 * Если найдено соответствие в столбце, то значение не может быть здесь
	    		 */
    			if(myBoard[i][c] == possibleValues[n]){
    				canBeHere = false;
    			}
	    	}
    		if(!canBeHere){
    			/*
    			 *  Если элемент не может быть в данном столбце,
    			 *  то удалить элемент из списка возможных значений
    			 */
    			for(int i = n + 1; i < positionCounter; i++){
    				possibleValues[i - 1] = possibleValues[i];
    			}
    			positionCounter--;
    		}
	    }
	    /* Проверить, могут ли оставшиеся значения присутствовать в зоне */
    	int row = r/3 * 3;		//Расчёт первой строки зоны
	    int column = c/3 * 3;	//Расчёт первого столбца зоны
	    for(int n = 0; n < positionCounter; n++){
	    	canBeHere = true;	//Установка параметра
	    	/* Последовательный перебор элементов зоны */
		    for(int i = row; i < row + 3; i++){
		    	for(int j = column; j < column + 3; j++){
		    		/* 
		    		 * При условии, что пустые клетки отмечаются отрицательным значением
		    		 * Если найдено соответствие в зоне, то значение не может быть здесь
		    		 */
		    		if(myBoard[i][j] == possibleValues[n]){
		    			canBeHere = false;
		    		}
		    	}
		    }
		    if(!canBeHere){
    			/*
    			 *  Если элемент не может быть в данной зоне,
    			 *  то удалить элемент из списка возможных значений
    			 */
    			for(int i = n + 1; i < positionCounter; i++){
    				possibleValues[i - 1] = possibleValues[i];
    			}
    			positionCounter--;
    		}
    	}
	    //Вернуть размер массива возможных значений
    	return positionCounter;
    }
}
